% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/normalisation.R
\name{normaliseExprs}
\alias{normaliseExprs}
\alias{normalizeExprs}
\alias{normliseExprs}
\title{Normalise expression expression levels for an SingleCellExperiment object}
\usage{
normaliseExprs(object, method = "none", design = NULL, feature_set = NULL,
  exprs_values = "counts", return_norm_as_exprs = TRUE, ...)

normalizeExprs(...)
}
\arguments{
\item{object}{an \code{SingleCellExperiment} object.}

\item{method}{character string specified the method of calculating
normalisation factors. Passed to \code{\link[edgeR]{calcNormFactors}}.}

\item{design}{design matrix defining the linear model to be fitted to the
normalised expression values. If not \code{NULL}, then the residuals of this
linear model fit are used as the normalised expression values.}

\item{feature_set}{character, numeric or logical vector indicating a set of
features to use for calculating normalisation factors. If character, entries
must all be in \code{featureNames(object)}. If numeric, values are taken to
be indices for features. If logical, vector is used to index features and should
have length equal to \code{nrow(object)}.}

\item{exprs_values}{character string indicating which slot of the
assayData from the \code{SingleCellExperiment} object should be used for the calculations.
Valid options are \code{'counts'}, \code{'tpm'}, \code{'cpm'}, \code{'fpkm'}
and \code{'exprs'}. Defaults to the first available value of these options in
in order shown.}

\item{return_norm_as_exprs}{logical, should the normalised expression values
be returned to the \code{exprs} slot of the object? Default is TRUE. If
FALSE, values in the \code{exprs} slot will be left untouched. Regardless,
normalised expression values will be returned to the \code{norm_exprs} slot
of the object.}

\item{...}{arguments passed to \code{normaliseExprs} (in the case of
\code{normalizeExprs}) or to \code{\link[edgeR]{calcNormFactors}}.}
}
\value{
an SingleCellExperiment object
}
\description{
Compute normalised expression values from an SingleCellExperiment object and return the
object with the normalised expression values added.
}
\details{
This function allows the user to compute normalised expression
values from an SingleCellExperiment object. The 'raw' values used can be the values in the
\code{'counts'} (default), \code{'tpm'}, \code{'cpm'} or \code{'fpkm'} slot
of the SingleCellExperiment. Normalised expression values are computed through
\code{\link{normalizeSCE}} and are on the log2-scale, with an offset
defined by the \code{logExprsOffset} slot of the SingleCellExperiment object. These are
dded to the \code{'norm_exprs'} slot of the returned object. If
\code{'exprs_values'} argument is \code{'counts'}, a \code{'norm_cpm'} slot
is also added, containing normalised counts-per-million values.

If the raw values are counts, this function will compute size factors using
methods in \code{\link[edgeR]{calcNormFactors}}. Library sizes are multiplied
by size factors to obtain an "effective library size" before calculation of
the aforementioned normalized expression values. If \code{feature_set} is
specified, only the specified features will be used to calculate the
size factors.

If the user wishes to remove the effects of certain explanatory variables,
then the \code{'design'} argument can be defined. The \code{design} argument
must be a valid design matrix, for example as produced by
\code{\link[stats]{model.matrix}}, with the relevant variables. A linear
model is then fitted using \code{\link[limma]{lmFit}} on expression values
after any size-factor and library size normalisation as descrived above. The
returned values in \code{'norm_exprs'} are the residuals from the linear
model fit.

After normalisation, normalised expression values can be accessed with the
\code{\link{norm_exprs}} function (with corresponding accessor functions for
counts, tpm, fpkm, cpm). These functions can also be used to assign normalised
expression values produced with external tools to a SingleCellExperiment object.

\code{normalizeExprs} is exactly the same as \code{normaliseExprs}, provided
for those who prefer North American spelling.
}
\examples{
data("sc_example_counts")
data("sc_example_cell_info")
example_sce <- SingleCellExperiment(
assays = list(counts = sc_example_counts), colData = sc_example_cell_info)
keep_gene <- rowSums(counts(example_sce)) > 0
example_sce <- example_sce[keep_gene,]

## Apply TMM normalisation taking into account all genes
example_sce <- normaliseExprs(example_sce, method = "TMM")
## Scale counts relative to a set of control features (here the first 100 features)
example_sce <- normaliseExprs(example_sce, method = "none",
feature_set = 1:100)

}
\author{
Davis McCarthy
}
