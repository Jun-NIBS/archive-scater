## A set of functions for calculating and summarising expression values

#' Calculate which features are expressed in which cells using a threshold on
#' observed counts, transcripts-per-million, counts-per-million, FPKM, or
#' defined expression levels.
#'
#' @param object an SCESet object with expression and/or count data.
#' @param lowerDetectionLimit numeric scalar giving the minimum expression level
#' for an expression observation in a cell for it to qualify as expressed.
#' @param exprs_values character scalar indicating whether the count data
#' (\code{"counts"}), the transformed expression data (\code{"exprs"}),
#' transcript-per-million (\code{"tpm"}), counts-per-million (\code{"cpm"}) or
#' FPKM (\code{"fpkm"}) should be used to define if an observation is expressed
#' or not. Defaults to the first available value of those options in the
#' order shown.
#' @return a logical matrix indicating whether or not a feature in a particular
#' cell is expressed.
#' @export
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' example_sceset <- newSCESet(countData=sc_example_counts)
#' is_exprs(example_sceset) <- calcIsExprs(example_sceset, lowerDetectionLimit = 1,
#' exprs_values = "exprs")
calcIsExprs <- function(object, lowerDetectionLimit = 0, exprs_values = "counts")
{
    assay(object, i=exprs_values) > lowerDetectionLimit
}

#' Count the number of expressed genes per cell
#'
#'
#' @param object an \code{SCESet} object
#' @param lowerDetectionLimit numeric scalar providing the value above which observations
#' are deemed to be expressed. Defaults to \code{object@lowerDetectionLimit}.
#' @param exprs_values character scalar indicating whether the count data
#' (\code{"counts"}), the transformed expression data (\code{"exprs"}),
#' transcript-per-million (\code{"tpm"}), counts-per-million (\code{"cpm"}) or
#' FPKM (\code{"fpkm"}) should be used to define if an observation is expressed
#' or not. Defaults to the first available value of those options in the
#' order shown. However, if \code{is_exprs(object)} is present, it will be
#' used directly; \code{exprs_values} and \code{lowerDetectionLimit} are ignored.
#' @param byrow logical scalar indicating if \code{TRUE} to count expressing
#' cells per feature (i.e. gene) and if \code{FALSE} to count expressing
#' features (i.e. genes) per cell.
#' @param subset_row logical, integeror character vector indicating which rows
#' (i.e. features/genes) to use when calculating the number of expressed
#' features in each cell, when \code{byrow=FALSE}.
#' @param subset_col logical, integer or character vector indicating which columns
#' (i.e., cells) to use to calculate the number of cells expressing each gene
#' when \code{byrow=TRUE}.
#'
#' @description An efficient internal function that avoids the need to construct
#' 'is_exprs_mat' by counting the number of expressed genes per cell on the fly.
#'
#' @return a numeric vector of the same length as the number of features if
#' \code{byrow} argument is \code{TRUE} and the same length as the number of
#' cells if \code{byrow} is \code{FALSE}
#'
#' @export
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' pd <- new("AnnotatedDataFrame", data=sc_example_cell_info)
#' rownames(pd) <- pd$Cell
#' example_sceset <- newSCESet(countData=sc_example_counts, phenoData=pd)
#' nexprs(example_sceset)[1:10]
#' nexprs(example_sceset, byrow = TRUE)[1:10]
#'
nexprs <- function(object, lowerDetectionLimit = 0, exprs_values = "counts", byrow = FALSE, subset_row = NULL, subset_col = NULL) {
    exprs_mat <- assay(object, i=exprs_values)
    subset_row <- .subset2index(subset_row, target=exprs_mat, byrow=TRUE)
    subset_col <- .subset2index(subset_col, target=exprs_mat, byrow=FALSE)

    if (!byrow) {
        margin.stats <- .Call(cxx_margin_summary, exprs_mat, lowerDetectionLimit,
                subset_row - 1L, FALSE)
        return(margin.stats[[2]][subset_col])
    } else {
        margin.stats <- .Call(cxx_margin_summary, exprs_mat, lowerDetectionLimit,
                subset_col - 1L, TRUE)
        return(margin.stats[[2]][subset_row])
    }
}

#' Calculate transcripts-per-million (TPM)
#'
#' Calculate transcripts-per-million (TPM) values for expression from counts for
#' a set of features.
#'
#' @param object an \code{SCESet} object
#' @param effective_length vector of class \code{"numeric"} providing the
#' effective length for each feature in the \code{SCESet} object
#' @param calc_from character string indicating whether to compute TPM from
#' \code{"counts"}, \code{"norm_counts"}, \code{"fpkm"} or \code{"norm_fpkm"}.
#' Default is to use \code{"counts"}, in which case the \code{effective_length}
#' argument must be supplied.
#'
#' @return Matrix of TPM values.
#' @export
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' pd <- new("AnnotatedDataFrame", data = sc_example_cell_info)
#' example_sceset <- newSCESet(countData = sc_example_counts, phenoData = pd)
#' effective_length <- rep(1000, 2000)
#' tpm(example_sceset) <- calculateTPM(example_sceset, effective_length,
#'     calc_from = "counts")
#'
#' ## calculate from FPKM
#' fpkm(example_sceset) <- calculateFPKM(example_sceset, effective_length)
#' tpm(example_sceset) <- calculateTPM(example_sceset, effective_length,
#'                                     calc_from = "fpkm")
#'
calculateTPM <- function(object, effective_length = NULL, calc_from = "counts") {
    if ( !is(object, "SCESet"))
        stop("object must be an SCESet")
    ## Check that arguments are correct
    calc_from <- match.arg(calc_from, c("counts", "norm_counts", "fpkm",
                                        "norm_fpkm"), several.ok = FALSE)
    if ( calc_from == "counts" || calc_from == "norm_counts" ) {
        if ( is.null(effective_length) )
            stop("effective_length argument is required if computing TPM from counts")
    }
    ## Compute values to return
    tpm_to_add <- switch(calc_from,
                         counts = .countToTpm(counts(object), effective_length),
                         norm_counts = .countToTpm(norm_counts(object),
                                                    effective_length),
                         fpkm = .fpkmToTpm(fpkm(object)),
                         norm_fpkm = .fpkmToTpm(norm_fpkm(object)))

    ## Return TPM values
    rownames(tpm_to_add) <- featureNames(object)
    colnames(tpm_to_add) <- colnames(object)
    tpm_to_add
}

.countToTpm <- function(counts, eff_len) {
    ## Expecting a count matrix of nfeatures x ncells
    ## can't have any zero counts, so expect to apply offset
    counts0 <- counts
    counts0[counts == 0] <- NA
    rate <- log(counts0) - log(eff_len)
    denom <- log(colSums(exp(rate), na.rm = TRUE))
    out <- exp( t(t(rate) - denom) + log(1e6) )
    out[is.na(out)] <- 0
    out
}

.countToFpkm <- function(counts, eff_len) {
    ## Expecting a count matrix of nfeatures x ncells
    ## Need to be careful with zero counts
    counts0 <- counts
    counts0[counts == 0] <- NA
    N <- colSums(counts)
    logfpkm <- log(counts0) + log(1e9) - log(eff_len)
    logfpkm <- t(t(logfpkm) - log(N))
    out <- exp( logfpkm )
    out[is.na(out)] <- 0
    out
}

.fpkmToTpm <- function(fpkm) {
    ## Expecting an FPKM matrix of nfeatures x ncells
    exp( t(t(log(fpkm)) - log(colSums(fpkm))) + log(1e6) )
}

.countToEffCounts <- function(counts, len, eff_len) {
    counts * (len / eff_len)
}


#' Calculate counts per million (CPM)
#'
#' Calculate count-per-million (CPM) values from the count data.
#'
#' @param object an \code{SCESet} object
#' @param use.size.factors a logical scalar specifying whether
#' the size factors should be used to construct effective library
#' sizes, or if the library size should be directly defined as
#' the sum of counts for each cell.
#'
#' @return Matrix of CPM values.
#' @export
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' example_sceset <- newSCESet(countData = sc_example_counts)
#' cpm(example_sceset) <- calculateCPM(example_sceset)
#'
calculateCPM <- function(object, use.size.factors = TRUE) {
    counts_mat <- counts(object)
    if (use.size.factors) {
        sf.list <- .get_all_sf_sets(object)
        if (is.null(sf.list$size.factors[[1]])) {
            warning("size factors requested but not specified, using library sizes instead")
            sf.list$size.factors[[1]] <- colSums(counts_mat)
        }
    } else {
        sf.list <- list(size.factors=list(colSums(counts_mat)),
                        index=rep(1, nrow(object)))
    }

    # Scaling the size factors to the library size.
    cpm_mat <- counts_mat
    mean.lib.size <- mean(colSums(counts_mat))
    by.type <- split(seq_along(sf.list$index), sf.list$index)

    for (g in seq_along(by.type)) {
        chosen <- by.type[[g]]
        sf <- sf.list$size.factors[[g]]
        scaled.sf <- sf/mean(sf) * mean.lib.size
        cpm_mat[chosen,] <- edgeR::cpm(counts_mat[chosen,,drop = FALSE],
                                       lib.size = scaled.sf)
    }

    # Restoring attributes.
    rownames(cpm_mat) <- featureNames(object)
    colnames(cpm_mat) <- colnames(object)
    return(cpm_mat)
}

#' Calculate fragments per kilobase of exon per million reads mapped (FPKM)
#'
#' Calculate fragments per kilobase of exon per million reads mapped (FPKM)
#' values for expression from counts for a set of features.
#'
#' @param object an \code{SCESet} object
#' @param effective_length vector of class \code{"numeric"} providing the
#' effective length for each feature in the \code{SCESet} object
#' @param use.size.factors a logical scalar, see \code{\link{calculateCPM}}
#'
#' @return Matrix of FPKM values.
#' @export
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' example_sceset <- newSCESet(countData = sc_example_counts)
#' effective_length <- rep(1000, 2000)
#' fpkm(example_sceset) <- calculateFPKM(example_sceset, effective_length)
#'
calculateFPKM <- function(object, effective_length, use.size.factors=TRUE) {
    if ( !is(object, "SCESet") )
        stop("object must be an SCESet")
    cpms <- calculateCPM(object, use.size.factors = use.size.factors)
    effective_length <- effective_length / 1e3
    cpms / effective_length
}


#' Calculate average counts, adjusting for size factors or library size
#'
#' Calculate average counts per feature, adjusting them as appropriate to take
#' into account for size factors for normalization or library sizes (total
#' counts).
#'
#' @param object an \code{SCESet} object
#'
#' @return Vector of average count values with same length as number of features.
#' @export
#' @examples
#' data("sc_example_counts")
#' data("sc_example_cell_info")
#' pd <- new("AnnotatedDataFrame", data = sc_example_cell_info)
#' example_sceset <- newSCESet(countData = sc_example_counts, phenoData = pd)
#'
#' ## calculate average counts
#' ave_counts <- calcAverage(example_sceset)
#'
calcAverage <- function(object, size.factors=NULL) {
    if (is(object, "SingleCellExperiment")) {
        sf.list <- .get_all_sf_sets(object)
        mat <- counts(object)
    } else {
        # Using the lone set of size factors, if provided.
        sf.list <- list(index=rep(1L, nrow(object)), size.factors=list(size.factors))
        mat <- object
    }

    # Set size factors to library sizes if not available.
    if (is.null(sf.list$size.factors[[1]])) {
        sf.list$size.factors[[1]] <- colSums(mat)
    }

    # Computes the average count, adjusting for size factors or library size.
    all.ave <- .compute_exprs(mat, sf.list$size.factors, sf_to_use = sf.list$index,
                              log = FALSE, sum = TRUE, logExprsOffset = 0,
                              subset_row = NULL)

    names(all.ave) <- rownames(mat)
    return(all.ave / ncol(mat))
}

